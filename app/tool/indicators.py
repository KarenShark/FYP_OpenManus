import asyncio
from typing import Any, Dict, List, Optional, Union

import numpy as np
from pydantic import BaseModel, Field

from app.logger import logger
from app.tool.base import BaseTool, ToolResult


class IndicatorSignal(BaseModel):
    """Represents a trading signal generated by technical indicators."""

    indicator: str = Field(description="Name of the indicator")
    signal: str = Field(description="Signal type: BUY, SELL, or HOLD")
    strength: float = Field(description="Signal strength from 0.0 to 1.0")
    value: float = Field(description="Current indicator value")
    description: str = Field(description="Human-readable signal description")


class IndicatorData(BaseModel):
    """Container for technical indicator calculations."""

    name: str = Field(description="Indicator name")
    values: List[float] = Field(description="Calculated indicator values")
    parameters: Dict[str, Any] = Field(description="Indicator parameters used")
    latest_value: Optional[float] = Field(
        default=None, description="Most recent indicator value"
    )


class TechnicalIndicatorsResponse(ToolResult):
    """Structured response from technical indicators calculation."""

    symbol: str = Field(description="Stock symbol analyzed")
    indicators: Dict[str, IndicatorData] = Field(
        default_factory=dict, description="Calculated technical indicators"
    )
    signals: List[IndicatorSignal] = Field(
        default_factory=list, description="Generated trading signals"
    )
    analysis_date: str = Field(description="Date of the analysis")

    def model_post_init(self, __context: Any) -> None:
        """Populate output field after model initialization."""
        if self.error:
            return

        if not self.indicators:
            self.output = f"No technical indicators calculated for {self.symbol}."
            return

        # Format output as readable text
        output_lines = [
            f"Technical Analysis for {self.symbol} ({self.analysis_date}):",
            "",
        ]

        # Add indicator values
        output_lines.append("Technical Indicators:")
        for name, data in self.indicators.items():
            latest = data.latest_value
            if latest is not None:
                output_lines.append(f"  {name}: {latest:.4f}")
                if data.parameters:
                    params_str = ", ".join(
                        [f"{k}={v}" for k, v in data.parameters.items()]
                    )
                    output_lines.append(f"    Parameters: {params_str}")

        # Add signals
        if self.signals:
            output_lines.extend(["", "Trading Signals:"])
            for signal in self.signals:
                strength_desc = (
                    "Strong"
                    if signal.strength > 0.7
                    else "Moderate" if signal.strength > 0.4 else "Weak"
                )
                output_lines.append(
                    f"  {signal.indicator}: {signal.signal} ({strength_desc})"
                )
                output_lines.append(f"    {signal.description}")
                output_lines.append(f"    Signal Strength: {signal.strength:.2f}")

        self.output = "\n".join(output_lines)


class TechnicalIndicators(BaseTool):
    """Calculate technical indicators and generate trading signals."""

    name: str = "technical_indicators"
    description: str = """Calculate technical indicators like SMA, EMA, RSI, MACD, and Bollinger Bands.
    Analyzes price data and generates trading signals based on indicator values.
    Supports multiple timeframes and customizable parameters."""

    parameters: dict = {
        "type": "object",
        "properties": {
            "price_data": {
                "type": "array",
                "description": "(required) Array of price data points. Each point should have 'close' price and optionally 'high', 'low', 'volume'.",
                "items": {
                    "type": "object",
                    "properties": {
                        "close": {"type": "number"},
                        "high": {"type": "number"},
                        "low": {"type": "number"},
                        "volume": {"type": "number"},
                        "date": {"type": "string"},
                    },
                    "required": ["close"],
                },
            },
            "indicators": {
                "type": "array",
                "description": "(optional) List of indicators to calculate. Available: SMA, EMA, RSI, MACD, BB (Bollinger Bands). Default is ['SMA', 'RSI'].",
                "items": {"type": "string"},
                "default": ["SMA", "RSI"],
            },
            "symbol": {
                "type": "string",
                "description": "(optional) Stock symbol for reference in output.",
                "default": "UNKNOWN",
            },
            "sma_period": {
                "type": "integer",
                "description": "(optional) Simple Moving Average period. Default is 20.",
                "default": 20,
            },
            "ema_period": {
                "type": "integer",
                "description": "(optional) Exponential Moving Average period. Default is 12.",
                "default": 12,
            },
            "rsi_period": {
                "type": "integer",
                "description": "(optional) RSI calculation period. Default is 14.",
                "default": 14,
            },
            "bb_period": {
                "type": "integer",
                "description": "(optional) Bollinger Bands period. Default is 20.",
                "default": 20,
            },
            "bb_std": {
                "type": "number",
                "description": "(optional) Bollinger Bands standard deviation multiplier. Default is 2.0.",
                "default": 2.0,
            },
        },
        "required": ["price_data"],
    }

    async def execute(
        self,
        price_data: List[Dict[str, Union[float, str]]],
        indicators: Optional[List[str]] = None,
        symbol: str = "UNKNOWN",
        sma_period: int = 20,
        ema_period: int = 12,
        rsi_period: int = 14,
        bb_period: int = 20,
        bb_std: float = 2.0,
    ) -> TechnicalIndicatorsResponse:
        """
        Calculate technical indicators and generate trading signals.

        Args:
            price_data: Array of price data points with at least 'close' prices
            indicators: List of indicators to calculate
            symbol: Stock symbol for reference
            sma_period: Simple Moving Average period
            ema_period: Exponential Moving Average period
            rsi_period: RSI calculation period
            bb_period: Bollinger Bands period
            bb_std: Bollinger Bands standard deviation multiplier

        Returns:
            TechnicalIndicatorsResponse with calculated indicators and signals
        """
        try:
            if indicators is None:
                indicators = ["SMA", "RSI"]

            if not price_data or len(price_data) < 2:
                error_msg = "Insufficient price data for technical analysis"
                logger.error(error_msg)
                return TechnicalIndicatorsResponse(
                    symbol=symbol, analysis_date="", error=error_msg
                )

            # Extract price arrays
            closes = np.array([float(d.get("close", 0)) for d in price_data])
            highs = np.array(
                [float(d.get("high", d.get("close", 0))) for d in price_data]
            )
            lows = np.array(
                [float(d.get("low", d.get("close", 0))) for d in price_data]
            )
            volumes = np.array([float(d.get("volume", 0)) for d in price_data])

            # Get analysis date
            analysis_date = (
                price_data[-1].get("date", "Unknown") if price_data else "Unknown"
            )

            logger.info(f"Calculating technical indicators for {symbol}: {indicators}")

            calculated_indicators = {}
            signals = []

            # Calculate requested indicators
            for indicator in indicators:
                indicator_upper = indicator.upper()

                if indicator_upper == "SMA":
                    result = await self._calculate_sma(closes, sma_period)
                    calculated_indicators["SMA"] = result
                    signals.extend(
                        await self._generate_sma_signals(closes, result, sma_period)
                    )

                elif indicator_upper == "EMA":
                    result = await self._calculate_ema(closes, ema_period)
                    calculated_indicators["EMA"] = result
                    signals.extend(
                        await self._generate_ema_signals(closes, result, ema_period)
                    )

                elif indicator_upper == "RSI":
                    result = await self._calculate_rsi(closes, rsi_period)
                    calculated_indicators["RSI"] = result
                    signals.extend(await self._generate_rsi_signals(result))

                elif indicator_upper == "MACD":
                    result = await self._calculate_macd(closes)
                    calculated_indicators["MACD"] = result
                    signals.extend(await self._generate_macd_signals(result))

                elif indicator_upper in ["BB", "BOLLINGER", "BOLLINGER_BANDS"]:
                    result = await self._calculate_bollinger_bands(
                        closes, bb_period, bb_std
                    )
                    calculated_indicators["Bollinger_Bands"] = result
                    signals.extend(await self._generate_bb_signals(closes, result))

            logger.info(
                f"Calculated {len(calculated_indicators)} indicators and generated {len(signals)} signals"
            )

            return TechnicalIndicatorsResponse(
                symbol=symbol,
                indicators=calculated_indicators,
                signals=signals,
                analysis_date=analysis_date,
            )

        except Exception as e:
            error_msg = f"Error calculating technical indicators: {str(e)}"
            logger.error(error_msg)
            return TechnicalIndicatorsResponse(
                symbol=symbol, analysis_date="", error=error_msg
            )

    async def _calculate_sma(self, prices: np.ndarray, period: int) -> IndicatorData:
        """Calculate Simple Moving Average."""
        if len(prices) < period:
            return IndicatorData(
                name="SMA", values=[], parameters={"period": period}, latest_value=None
            )

        sma_values = []
        for i in range(len(prices)):
            if i >= period - 1:
                sma = np.mean(prices[i - period + 1 : i + 1])
                sma_values.append(float(sma))
            else:
                sma_values.append(np.nan)

        # Filter out NaN values for latest_value
        valid_values = [v for v in sma_values if not np.isnan(v)]
        latest_value = valid_values[-1] if valid_values else None

        return IndicatorData(
            name="SMA",
            values=sma_values,
            parameters={"period": period},
            latest_value=latest_value,
        )

    async def _calculate_ema(self, prices: np.ndarray, period: int) -> IndicatorData:
        """Calculate Exponential Moving Average."""
        if len(prices) == 0:
            return IndicatorData(
                name="EMA", values=[], parameters={"period": period}, latest_value=None
            )

        alpha = 2.0 / (period + 1)
        ema_values = [float(prices[0])]  # Start with first price

        for i in range(1, len(prices)):
            ema = alpha * prices[i] + (1 - alpha) * ema_values[-1]
            ema_values.append(float(ema))

        return IndicatorData(
            name="EMA",
            values=ema_values,
            parameters={"period": period},
            latest_value=ema_values[-1] if ema_values else None,
        )

    async def _calculate_rsi(self, prices: np.ndarray, period: int) -> IndicatorData:
        """Calculate Relative Strength Index."""
        if len(prices) < period + 1:
            return IndicatorData(
                name="RSI", values=[], parameters={"period": period}, latest_value=None
            )

        # Calculate price changes
        deltas = np.diff(prices)
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)

        # Calculate average gains and losses
        avg_gains = []
        avg_losses = []
        rsi_values = []

        for i in range(len(deltas)):
            if i < period:
                rsi_values.append(np.nan)
                continue

            if i == period:
                # Initial averages
                avg_gain = np.mean(gains[i - period + 1 : i + 1])
                avg_loss = np.mean(losses[i - period + 1 : i + 1])
            else:
                # Smoothed averages
                avg_gain = (avg_gains[-1] * (period - 1) + gains[i]) / period
                avg_loss = (avg_losses[-1] * (period - 1) + losses[i]) / period

            avg_gains.append(avg_gain)
            avg_losses.append(avg_loss)

            # Calculate RSI
            if avg_loss == 0:
                rsi = 100
            else:
                rs = avg_gain / avg_loss
                rsi = 100 - (100 / (1 + rs))

            rsi_values.append(float(rsi))

        # Add initial NaN for the first price (no change)
        rsi_values = [np.nan] + rsi_values

        # Get latest valid RSI value
        valid_values = [v for v in rsi_values if not np.isnan(v)]
        latest_value = valid_values[-1] if valid_values else None

        return IndicatorData(
            name="RSI",
            values=rsi_values,
            parameters={"period": period},
            latest_value=latest_value,
        )

    async def _calculate_macd(self, prices: np.ndarray) -> IndicatorData:
        """Calculate MACD (Moving Average Convergence Divergence)."""
        if len(prices) < 26:
            return IndicatorData(
                name="MACD",
                values=[],
                parameters={"fast_period": 12, "slow_period": 26, "signal_period": 9},
                latest_value=None,
            )

        # Calculate EMAs
        ema_12 = await self._calculate_ema(prices, 12)
        ema_26 = await self._calculate_ema(prices, 26)

        # Calculate MACD line
        macd_values = []
        for i in range(len(prices)):
            if i >= 25:  # Need at least 26 points for EMA26
                macd = ema_12.values[i] - ema_26.values[i]
                macd_values.append(float(macd))
            else:
                macd_values.append(np.nan)

        # Calculate signal line (9-period EMA of MACD)
        valid_macd = np.array([v for v in macd_values if not np.isnan(v)])
        if len(valid_macd) >= 9:
            signal_ema = await self._calculate_ema(valid_macd, 9)
            latest_value = macd_values[-1] if not np.isnan(macd_values[-1]) else None
        else:
            latest_value = None

        return IndicatorData(
            name="MACD",
            values=macd_values,
            parameters={"fast_period": 12, "slow_period": 26, "signal_period": 9},
            latest_value=latest_value,
        )

    async def _calculate_bollinger_bands(
        self, prices: np.ndarray, period: int, std_mult: float
    ) -> IndicatorData:
        """Calculate Bollinger Bands."""
        if len(prices) < period:
            return IndicatorData(
                name="Bollinger_Bands",
                values=[],
                parameters={"period": period, "std_multiplier": std_mult},
                latest_value=None,
            )

        sma_data = await self._calculate_sma(prices, period)
        sma_values = np.array(sma_data.values)

        upper_band = []
        lower_band = []
        middle_band = sma_values

        for i in range(len(prices)):
            if i >= period - 1:
                std_dev = np.std(prices[i - period + 1 : i + 1])
                upper = sma_values[i] + (std_mult * std_dev)
                lower = sma_values[i] - (std_mult * std_dev)
                upper_band.append(float(upper))
                lower_band.append(float(lower))
            else:
                upper_band.append(np.nan)
                lower_band.append(np.nan)

        # Return as combined data structure
        bb_data = {
            "upper": upper_band,
            "middle": middle_band.tolist(),
            "lower": lower_band,
        }

        # Latest value is the current position relative to bands
        if not np.isnan(upper_band[-1]) and not np.isnan(lower_band[-1]):
            current_price = prices[-1]
            band_width = upper_band[-1] - lower_band[-1]
            position = (
                (current_price - lower_band[-1]) / band_width if band_width > 0 else 0.5
            )
            latest_value = float(
                position
            )  # 0 = at lower band, 1 = at upper band, 0.5 = at middle
        else:
            latest_value = None

        return IndicatorData(
            name="Bollinger_Bands",
            values=[bb_data],  # Store as single complex value
            parameters={"period": period, "std_multiplier": std_mult},
            latest_value=latest_value,
        )

    async def _generate_sma_signals(
        self, prices: np.ndarray, sma_data: IndicatorData, period: int
    ) -> List[IndicatorSignal]:
        """Generate trading signals from SMA."""
        if not sma_data.latest_value or len(prices) < 2:
            return []

        current_price = prices[-1]
        sma_value = sma_data.latest_value

        # Price vs SMA crossover signal
        if current_price > sma_value:
            strength = min(
                (current_price - sma_value) / sma_value * 10, 1.0
            )  # Scale to 0-1
            return [
                IndicatorSignal(
                    indicator="SMA",
                    signal="BUY",
                    strength=float(strength),
                    value=sma_value,
                    description=f"Price ({current_price:.2f}) is above SMA({period}): {sma_value:.2f}",
                )
            ]
        elif current_price < sma_value:
            strength = min((sma_value - current_price) / sma_value * 10, 1.0)
            return [
                IndicatorSignal(
                    indicator="SMA",
                    signal="SELL",
                    strength=float(strength),
                    value=sma_value,
                    description=f"Price ({current_price:.2f}) is below SMA({period}): {sma_value:.2f}",
                )
            ]
        else:
            return [
                IndicatorSignal(
                    indicator="SMA",
                    signal="HOLD",
                    strength=0.1,
                    value=sma_value,
                    description=f"Price ({current_price:.2f}) is at SMA({period}): {sma_value:.2f}",
                )
            ]

    async def _generate_ema_signals(
        self, prices: np.ndarray, ema_data: IndicatorData, period: int
    ) -> List[IndicatorSignal]:
        """Generate trading signals from EMA."""
        if not ema_data.latest_value or len(prices) < 2:
            return []

        current_price = prices[-1]
        ema_value = ema_data.latest_value

        # Similar to SMA but with EMA
        if current_price > ema_value:
            strength = min((current_price - ema_value) / ema_value * 10, 1.0)
            return [
                IndicatorSignal(
                    indicator="EMA",
                    signal="BUY",
                    strength=float(strength),
                    value=ema_value,
                    description=f"Price ({current_price:.2f}) is above EMA({period}): {ema_value:.2f}",
                )
            ]
        elif current_price < ema_value:
            strength = min((ema_value - current_price) / ema_value * 10, 1.0)
            return [
                IndicatorSignal(
                    indicator="EMA",
                    signal="SELL",
                    strength=float(strength),
                    value=ema_value,
                    description=f"Price ({current_price:.2f}) is below EMA({period}): {ema_value:.2f}",
                )
            ]
        else:
            return [
                IndicatorSignal(
                    indicator="EMA",
                    signal="HOLD",
                    strength=0.1,
                    value=ema_value,
                    description=f"Price ({current_price:.2f}) is at EMA({period}): {ema_value:.2f}",
                )
            ]

    async def _generate_rsi_signals(
        self, rsi_data: IndicatorData
    ) -> List[IndicatorSignal]:
        """Generate trading signals from RSI."""
        if not rsi_data.latest_value:
            return []

        rsi_value = rsi_data.latest_value

        if rsi_value >= 70:
            strength = min((rsi_value - 70) / 30, 1.0)  # Scale from 70-100 to 0-1
            return [
                IndicatorSignal(
                    indicator="RSI",
                    signal="SELL",
                    strength=float(strength),
                    value=rsi_value,
                    description=f"RSI is in overbought territory: {rsi_value:.2f}",
                )
            ]
        elif rsi_value <= 30:
            strength = min((30 - rsi_value) / 30, 1.0)  # Scale from 30-0 to 0-1
            return [
                IndicatorSignal(
                    indicator="RSI",
                    signal="BUY",
                    strength=float(strength),
                    value=rsi_value,
                    description=f"RSI is in oversold territory: {rsi_value:.2f}",
                )
            ]
        else:
            return [
                IndicatorSignal(
                    indicator="RSI",
                    signal="HOLD",
                    strength=0.2,
                    value=rsi_value,
                    description=f"RSI is in neutral territory: {rsi_value:.2f}",
                )
            ]

    async def _generate_macd_signals(
        self, macd_data: IndicatorData
    ) -> List[IndicatorSignal]:
        """Generate trading signals from MACD."""
        if not macd_data.latest_value:
            return []

        macd_value = macd_data.latest_value

        # Simple MACD signal based on positive/negative
        if macd_value > 0:
            strength = min(abs(macd_value) * 0.1, 1.0)  # Scale based on magnitude
            return [
                IndicatorSignal(
                    indicator="MACD",
                    signal="BUY",
                    strength=float(strength),
                    value=macd_value,
                    description=f"MACD is positive (bullish): {macd_value:.4f}",
                )
            ]
        elif macd_value < 0:
            strength = min(abs(macd_value) * 0.1, 1.0)
            return [
                IndicatorSignal(
                    indicator="MACD",
                    signal="SELL",
                    strength=float(strength),
                    value=macd_value,
                    description=f"MACD is negative (bearish): {macd_value:.4f}",
                )
            ]
        else:
            return [
                IndicatorSignal(
                    indicator="MACD",
                    signal="HOLD",
                    strength=0.1,
                    value=macd_value,
                    description=f"MACD is neutral: {macd_value:.4f}",
                )
            ]

    async def _generate_bb_signals(
        self, prices: np.ndarray, bb_data: IndicatorData
    ) -> List[IndicatorSignal]:
        """Generate trading signals from Bollinger Bands."""
        if not bb_data.latest_value or not bb_data.values:
            return []

        current_price = prices[-1]
        position = bb_data.latest_value  # Position within bands (0-1)

        if position >= 0.9:  # Near upper band
            strength = min((position - 0.9) / 0.1, 1.0)
            return [
                IndicatorSignal(
                    indicator="Bollinger_Bands",
                    signal="SELL",
                    strength=float(strength),
                    value=position,
                    description=f"Price ({current_price:.2f}) is near upper Bollinger Band (position: {position:.2f})",
                )
            ]
        elif position <= 0.1:  # Near lower band
            strength = min((0.1 - position) / 0.1, 1.0)
            return [
                IndicatorSignal(
                    indicator="Bollinger_Bands",
                    signal="BUY",
                    strength=float(strength),
                    value=position,
                    description=f"Price ({current_price:.2f}) is near lower Bollinger Band (position: {position:.2f})",
                )
            ]
        else:
            return [
                IndicatorSignal(
                    indicator="Bollinger_Bands",
                    signal="HOLD",
                    strength=0.2,
                    value=position,
                    description=f"Price ({current_price:.2f}) is within normal Bollinger Band range (position: {position:.2f})",
                )
            ]


if __name__ == "__main__":
    # Test the tool with sample data
    sample_data = [
        {"close": 100, "high": 102, "low": 98, "date": "2024-01-01"},
        {"close": 102, "high": 104, "low": 100, "date": "2024-01-02"},
        {"close": 101, "high": 103, "low": 99, "date": "2024-01-03"},
        {"close": 103, "high": 105, "low": 101, "date": "2024-01-04"},
        {"close": 105, "high": 107, "low": 103, "date": "2024-01-05"},
    ] * 10  # Repeat to have enough data

    indicators_tool = TechnicalIndicators()
    result = asyncio.run(
        indicators_tool.execute(
            price_data=sample_data, symbol="TEST", indicators=["SMA", "RSI", "MACD"]
        )
    )
    print(result.output if result.output else result.error)
